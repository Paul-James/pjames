% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hashcol.R
\name{hashcol}
\alias{hashcol}
\title{Create a grouped hash table instead of using split()}
\usage{
hashcol(X, n.cores = parallel::detectCores() - 1)
}
\arguments{
\item{X}{A dataframe column you want to group by. IE: \code{df$id}}

\item{n.cores}{An integer value that indicates the number of cores you want to run the process on. The default is 1 less than the total number of available cores on the CPU for UNIX flavored OSs, while the only option (currently) on Windows OS is 1.}
}
\description{
Takes a dataframe column you want to group by and returns a hash table. The keys are the unique values of the group by column and the values are the row numbers where each key is found. This is parallelized across all available cores on your CPU and is a direct and much faster replacement of split(df, df$group_by).
}
\details{
Check the OS and chooses the correct package to use for mclapply. The pkg \code{parallelsugar} can be used for Windows (...but it's currently not) while \code{parallel} is used for everything else.

WARNING FOR WINDOWS USERS: not paralellized; only runs \code{lapply} instead of \code{mclapply}.
}
\examples{
asd <- data.frame(
    id               = rep(letters, times = 5)
  , service          = sample(
      c('ps1', 'ps2', 'ps3', 'ps4', 'ps5', 'ps6', 'ps7')
    , size    = 26 * 5
    , replace = TRUE
    )
  , stringsAsFactors = FALSE
  )
h <- hashcol(asd$id, n.cores = 1)
h

hash::keys(h)
hash::values(h)

h[hash::keys(h)[26]] # key value pair
h[[hash::keys(h)[26]]] # value accessor method; same as next line
hash::values(h)[ , 26] # value accessor method; same as previous line

}
\seealso{
\code{\link[parallel]{mclapply}}, \code{\link[hash]{hash}}
}
\keyword{dict}
\keyword{hash}
\keyword{map}
\keyword{parallel}
\keyword{split}
